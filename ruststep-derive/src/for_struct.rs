use inflector::Inflector;
use proc_macro2::{Span, TokenStream as TokenStream2};
use proc_macro_crate::*;
use quote::quote;

use super::*;

/// This must be same between codegens
fn table_arg() -> syn::Ident {
    syn::Ident::new("table", Span::call_site())
}

/// Map `A` to `PlaceHolder<AHolder>`
fn as_place_holder(input: &syn::Path) -> syn::Path {
    let syn::Path {
        leading_colon,
        mut segments,
    } = input.clone();
    let last_seg = segments.last_mut().unwrap();
    match &mut last_seg.arguments {
        // non-generic path
        syn::PathArguments::None => {
            let ruststep = ruststep_crate();
            let holder_ident = as_holder_ident(&last_seg.ident);
            return syn::parse_quote! { #ruststep::place_holder::PlaceHolder<#holder_ident> };
        }
        // generic path, e.g. Option<T>
        syn::PathArguments::AngleBracketed(syn::AngleBracketedGenericArguments {
            args, ..
        }) => {
            for arg in args {
                if let syn::GenericArgument::Type(syn::Type::Path(path)) = arg {
                    path.path = as_place_holder(&path.path);
                }
            }
            return syn::Path {
                leading_colon,
                segments,
            };
        }
        _ => unimplemented!(),
    }
}

fn preprocess_attributes(
    st: &syn::DataStruct,
) -> (Vec<&syn::Ident>, Vec<syn::Path>, Vec<TokenStream2>) {
    let table_arg = table_arg();

    let mut attrs = Vec::new();
    let mut types = Vec::new();
    let mut into_owned = Vec::new();

    for field in &st.fields {
        let ident = field
            .ident
            .as_ref()
            .expect("Tuple struct case is not supported");
        attrs.push(ident);

        let path = if let syn::Type::Path(syn::TypePath { path, .. }) = &field.ty {
            path
        } else {
            panic!("non-path field is not supported for derive(Holder)")
        };

        if is_use_place_holder(&field.attrs) {
            types.push(as_place_holder(path));
            into_owned.push(quote! { #ident.into_owned(#table_arg)? })
        } else {
            types.push(path.clone());
            into_owned.push(quote! { #ident })
        }
    }
    (attrs, types, into_owned)
}

pub fn def_holder(ident: &syn::Ident, st: &syn::DataStruct) -> TokenStream2 {
    let holder_ident = as_holder_ident(ident);
    let (attrs, attr_types, _) = preprocess_attributes(st);
    quote! {
        /// Auto-generated by `#[derive(Holder)]`
        #[derive(Debug, Clone, PartialEq, ::serde::Deserialize)]
        pub struct #holder_ident {
            #(#attrs: #attr_types),*
        }
    }
}

pub fn impl_holder(ident: &syn::Ident, table: &TableAttr, st: &syn::DataStruct) -> TokenStream2 {
    let name = ident.to_string().to_screaming_snake_case();
    let holder_ident = as_holder_ident(ident);
    let (attrs, _, into_owned) = preprocess_attributes(st);
    let attr_len = attrs.len();
    let TableAttr { table, .. } = table;
    let table_arg = table_arg();
    let ruststep = ruststep_crate();

    quote! {
        #[automatically_derived]
        impl #ruststep::tables::Holder for #holder_ident {
            type Table = #table;
            type Owned = #ident;
            fn into_owned(self, #table_arg: &Self::Table) -> #ruststep::error::Result<Self::Owned> {
                let #holder_ident { #(#attrs),* } = self;
                Ok(#ident { #(#attrs : #into_owned),* })
            }
            fn name() -> &'static str {
                #name
            }
            fn attr_len() -> usize {
                #attr_len
            }
        }
    } // quote!
}

pub fn impl_entity_table(ident: &syn::Ident, table: &TableAttr) -> TokenStream2 {
    let TableAttr { table, field } = table;
    let holder_ident = as_holder_ident(ident);
    let ruststep = ruststep_crate();

    quote! {
        #[automatically_derived]
        impl #ruststep::tables::EntityTable<#holder_ident> for #table {
            fn get_owned(&self, entity_id: u64) -> #ruststep::error::Result<#ident> {
                #ruststep::tables::get_owned(self, &self.#field, entity_id)
            }
            fn owned_iter<'table>(&'table self) -> Box<dyn Iterator<Item = #ruststep::error::Result<#ident>> + 'table> {
                #ruststep::tables::owned_iter(self, &self.#field)
            }
        }
    }
}

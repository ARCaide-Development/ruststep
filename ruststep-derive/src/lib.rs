//! proc-macro for ruststep
//!
//! ```
//! pub struct Table; // moc table struct
//!
//! #[derive(Debug, Clone, PartialEq, ruststep_derive::Holder)]
//! #[holder(table = Table)]
//! pub struct A {
//!     pub x: f64,
//!     pub y: f64,
//! }
//! ```
//!
//! `#[derive(Holder)]` generates followings:
//!
//! - `AHolder` struct
//!   - naming rule is `{}Holder`
//! - `impl Holder for AHolder`
//!   - `#[holder(table = ...)]` is consumed here
//! - `impl Deserialize for AHolder`
//! - `AHolderVisitor` struct for implementing `Deserialize`
//!   - naming rule is `{}HolderVisitor`
//!   - This struct is usually generated by [serde::Deserialize] proc-macro,
//!     but their definition does not match for our cases.
//!

use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use proc_macro_crate::*;
use quote::{format_ident, quote};

#[proc_macro_derive(Holder, attributes(holder))]
pub fn derive_holder(input: TokenStream) -> TokenStream {
    impl_holder(&syn::parse(input).unwrap()).into()
}

/// To parse `#[holder(table = Table)]` attribute
#[derive(Debug)]
struct TableAttr {
    table: syn::Ident,
    eq: syn::Token![=],
    name: syn::Ident,
}

impl syn::parse::Parse for TableAttr {
    fn parse(input: syn::parse::ParseStream) -> syn::parse::Result<Self> {
        Ok(TableAttr {
            table: input.parse()?,
            eq: input.parse()?,
            name: input.parse()?,
        })
    }
}

fn get_table_ident(ast: &syn::DeriveInput) -> syn::Ident {
    for attr in &ast.attrs {
        if attr.path.is_ident("holder") {
            let table: TableAttr = attr.parse_args().unwrap();
            return table.name;
        }
    }
    panic!("Table is not specified for Holder")
}

fn holder_ident(ident: &syn::Ident) -> syn::Ident {
    format_ident!("{}Holder", ident)
}

fn holder_visitor_ident(ident: &syn::Ident) -> syn::Ident {
    format_ident!("{}HolderVisitor", ident)
}

fn ruststep_path() -> TokenStream2 {
    let path = crate_name("ruststep").unwrap();
    match path {
        FoundCrate::Itself => quote! { crate },
        FoundCrate::Name(name) => {
            let ident = syn::Ident::new(&name, Span::call_site());
            quote! { ::#ident }
        }
    }
}

fn impl_holder(ast: &syn::DeriveInput) -> TokenStream2 {
    let table = get_table_ident(ast);
    let ident = &ast.ident;
    match &ast.data {
        syn::Data::Struct(st) => {
            let def_holder_tt = def_holder_for_struct(ident, st);
            let def_visitor_tt = def_visitor_for_struct(ident, st);
            let impl_deserialize_tt = impl_deserialize_for_struct(ident);
            let impl_holder_tt = impl_holder_for_struct(ident, &table, st);
            quote! {
                #def_holder_tt
                #def_visitor_tt
                #impl_deserialize_tt
                #impl_holder_tt
            }
        }
        _ => unimplemented!("Only struct is supprted currently"),
    }
}

fn def_holder_for_struct(ident: &syn::Ident, st: &syn::DataStruct) -> TokenStream2 {
    let holder_ident = holder_ident(ident);
    let attrs: Vec<_> = st.fields.iter().map(|field| &field.ident).collect();
    let attr_types: Vec<_> = st.fields.iter().map(|field| &field.ty).collect();
    quote! {
        #[derive(Debug, Clone, PartialEq)]
        pub struct #holder_ident {
            #(#attrs: #attr_types),*
        }
    }
}

fn impl_holder_for_struct(
    ident: &syn::Ident,
    table: &syn::Ident,
    st: &syn::DataStruct,
) -> TokenStream2 {
    let name = ident.to_string();
    let holder_ident = holder_ident(ident);
    let visitor_ident = holder_visitor_ident(ident);
    let attrs: Vec<_> = st.fields.iter().map(|field| &field.ident).collect();
    let attr_len = st.fields.len();
    let ruststep = ruststep_path();
    quote! {
        impl #ruststep::tables::Holder for #holder_ident {
            type Table = #table;
            type Owned = #ident;
            type Visitor = #visitor_ident;
            fn into_owned(self, _tables: &Self::Table) -> #ruststep::error::Result<Self::Owned> {
                let #holder_ident { #(#attrs),* } = self;
                Ok(#ident { #(#attrs),* })
            }
            fn name() -> &'static str {
                #name
            }
            fn attr_len() -> usize {
                #attr_len
            }
            fn visitor_new() -> Self::Visitor {
                #visitor_ident {}
            }
        }
    } // quote!
}

fn impl_deserialize_for_struct(ident: &syn::Ident) -> TokenStream2 {
    let holder_ident = holder_ident(ident);
    let ruststep = ruststep_path();
    quote! {
        impl<'de> ::serde::de::Deserialize<'de> for #holder_ident {
            fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
            where
                D: ::serde::de::Deserializer<'de>,
            {
                use #ruststep::tables::Holder;
                deserializer.deserialize_tuple_struct(Self::name(), Self::attr_len(), Self::visitor_new())
            }
        }
    } // quote!
}

fn def_visitor_for_struct(ident: &syn::Ident, st: &syn::DataStruct) -> TokenStream2 {
    let name = ident.to_string();
    let holder_ident = holder_ident(ident);
    let visitor_ident = holder_visitor_ident(ident);
    let attrs: Vec<_> = st.fields.iter().map(|field| &field.ident).collect();
    let ruststep = ruststep_path();
    quote! {
        pub struct #visitor_ident;

        impl<'de> ::serde::de::Visitor<'de> for #visitor_ident {
            type Value = #holder_ident;
            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(formatter, #name)
            }

            fn visit_seq<A>(self, mut seq: A) -> ::std::result::Result<Self::Value, A::Error>
            where
                A: ::serde::de::SeqAccess<'de>,
            {
                use #ruststep::tables::Holder;
                if let Some(size) = seq.size_hint() {
                    if size != #holder_ident::attr_len() {
                        todo!("Create another error and send it")
                    }
                }
                #(
                    let #attrs = seq.next_element()?.unwrap();
                )*
                Ok(#holder_ident { #(#attrs),* })
            }

            // Entry point for Record or Parameter::Typed
            fn visit_map<A>(self, mut map: A) -> ::std::result::Result<Self::Value, A::Error>
            where
                A: ::serde::de::MapAccess<'de>,
            {
                use #ruststep::tables::Holder;
                let key: String = map
                    .next_key()?
                    .expect("Empty map cannot be accepted as ruststep Holder"); // this must be a bug, not runtime error
                if key != #holder_ident::name() {
                    todo!("Create Error type and send it")
                }
                let value = map.next_value()?; // send to Self::visit_seq
                Ok(value)
            }
        }
    } // quote
}
